

# Phylogenetic and  Ancestral State Reconstruction of Target-seq Sample 

This document outlines the  pipeline for inferring tumor evolution and metastatic spread from targeted sequencing data. The workflow progresses from variant allele frequencies (VAFs) to a fully annotated phylogeographic tree. 


## Step 1: Data Preparation (VAF to Binary Sequence)

```r
data_amp <- fread("data/amp_case1.txt")
vaf_thred = 0.05

res_sample <- mutate(data, 
              seq = if_else(maf >= vaf_thred, Var, Wild)) %>% 
  select(site, sample, seq) %>% 
  filter(!site %in% duplicated_site) %>% 
  arrange(site, sample)
  
res_normal <- select(data, site, seq = Wild) %>%
	distinct() %>%
	mutate(sample = "NORMAL" )
  
res <- rbind(res_sample, res_normal) %>%
  mutate(sample = paste0(">", sample)) %>% 
  group_by(sample) %>% 
  reframe(seq = paste0(seq, collapse = "")) %>% 
  t() %>% as.vector()  
  
writeLines(res, "res/amp_sample_phylogeography/case1.fa")
```

## Step 2: Bayesian Phylogenetic Inference with BEAST

### 2.1 nucleotide substitution model selection with ModelFinder

```sh
iqtree2 -s res/amp_sample_phylogeography/case1.fa \
	 -m MFP -mset beast2 \
	 -o NORMAL   -B 1000 \
	 --prefix  res/amp_sample_phylogeography/model_test

```

Best-fit model according to BIC: JC+R2


### 2.2 Clock Model & Tree Prior selection using Path Sampling


Four model combination were test using Pathing sampling 

1. **Uncorrelated Relaxed Log-Normal Clock** + **Exponential Growth Population Size**
2. **Strict Clock** + **Exponential Growth Population Size**
3. **Uncorrelated Relaxed Log-Normal Clock** + **Constant Population Size**
4. **Strict Clock** + **Constant Population Size**


Four XML files were created using BEAUti (v2.6.3) , load sequence alignment and  set to Site Model to "JC+R" , and set corresponding Tree Prior and Clock Model. 


Four model combinations were applied in BEAST (v2.6.3) run MCMC with 100 steps and each with 1000000 chain length.


The Marginal_Likelihood_Value were calculated and recorded for each of the four models

| ID  | Tree Prior  | Clock Model | Log Marginal Likelihood | 2 * Diff ML |
| --- | ----------- | ----------- | ----------------------- | ----------- |
| 1   | exponential | logClock    | -2766.19                | 91.50       |
| 2   | exponential | strictClock | -2811.94                | 20.74       |
| 3   | constant    | strictClock | -2822.31                | 10.82       |
| 4   | constant    | logClock    | -2827.72                | 0           |

A Model Combination (exponential + logClock)  is favor with strong evidence (2 * Diff ML >10) 

### 2.3 MCMC analysis and Post-processing

After selecting the best-fit models, the final, full-length MCMC (Markov Chain Monte Carlo) analysis is performed to generate the posterior distribution of trees and parameters. This is the main computational step that produces the results for downstream analysis.

The analysis was run in **BEAST (v2.6.3)** using the optimal model combination determined through path sampling:

- **Site Model**: **JC+R2**
    
- **Clock Model**: **Uncorrelated Relaxed Log-Normal Clock**
    
- **Tree Prior**: **Exponential Growth Population Size**
    

The MCMC chain was run for 5e9 generations, with both parameters and trees logged every 5000 generations.  


Convergence of the MCMC analysis was assessed in Tracer (v1.7.1) to ensure the reliability of the results with the Effective Sample Size (ESS) above 200. The MCC tree was calculated using TreeAnnotator with 20% trees Burn-in and a median node height.



## Step 3: Ancestral State Reconstruction with RASP

To reconstruct the spatial history of the tumor, we performed a phylogeographic analysis using the Reconstruct Ancestral State in Phylogenies (RASP) software. 

The analysis requires two key inputs: the posterior set of trees generated by BEAST and a file assigning each tumor sample to a discrete "state" corresponding to its anatomical location (e.g., PI, PO, LM1, LM2, LM3, LM4). To ensure statistical rigor, we systematically tested a suite of biogeographic models (including DEC, DIVALIKE, and BAYAREALIKE). 


The best-fit model, BAYAREALIKE+J, was selected based on having the lowest Akaike Information Criterion corrected (AICc) value.






## Step 4 : Results Ploting

The results were visualized by annotating the inferred ancestral locations onto the summary Maximum Clade Credibility (MCC) tree. To ensure the robustness of our conclusions, we only displayed high-confidence inferences that met two strict criteria: the node itself had to have a posterior probability greater than 0.8, and the inferred ancestral location for that node had to have a marginal probability exceeding 0.5.

```r
wkdir <- "/public/data/cqh_project/crc/amp_case1/"
setwd(wkdir)
library(tidyverse)
library(data.table)
library(parallel)
library(treedataverse)
library(PieGlyph)
library(ggnewscale)

source("~/software/script_tools/R_color.R")
source("~/software/script_tools/function_lib.R")

# result ----
rscp_res_file <- "res_rasp/rasp/case1_amp_bd_rasp.txt"
node_info_file <- "res_rasp/rasp/case1_amp_bd_rasp_node_info.csv"
tree_file <- "res_rasp/rasp/mrca_case1_bd-cut005.trees"

select_model <- "BAYAREALIKE+j"


# read raw data -----
skip_nrow <- readLines(rscp_res_file) %>% 
  str_detect(paste0(best_model," ")) %>% 
  which()

node_distribution_raw <- fread(file = rscp_res_file, 
                               skip = skip_nrow, 
                               nrows = tip_num - 1,
                               sep = ":",
                               header = F) %>% 
  `colnames<-`(c("node", "text"))

node_distribution_raw <- lapply(1:nrow(node_distribution_raw), function(i){
  node = node_distribution_raw$node[i] %>%
    str_extract(pattern = "(?<= ).*")
  
  node_distribution_raw$text[i] %>%
    str_split(pattern = " ", simplify = T) %>% 
    matrix(ncol = 2, byrow = T) %>% 
    as.data.frame() %>% 
    `colnames<-`(c("region", "region_prob")) %>% 
    mutate(node = node) %>% 
    mutate(region_prob = as.numeric(region_prob))
  
})  %>%
  do.call( what = rbind) %>%
  mutate(node = as.numeric(node))


tip_distribution_raw <- fread(rscp_res_file, skip = 2, nrows = tip_num) %>% 
  `colnames<-`(c("idx", "label", "region"))  %>% 
  select(-idx)


region_list <- unique(tip_distribution_raw$region) %>%
  str_split(pattern = "" ) %>%
  unlist() %>% unique() %>% sort()

region_tab <- data.frame(region = region_list, 
                         region_real = c("Normal","PI", "PO", "LM1", "LM2", "LM3", "LM4")%>% 
                           factor(level = c("Normal","PI", "PO", "LM1", "LM2", "LM3", "LM4")))


## get tip distribution
tip_region <- expand_grid(tip_distribution_raw,
                          region_sep = region_list)  %>% 
  mutate(value = if_else(str_detect(region, region_sep), 1, 0)) %>% 
  filter(value  > 0) %>% 
  left_join(region_tab, by = c("region_sep" = "region")) %>% 
  mutate(idx = paste0("reg",rank(region_real)), .by = label) %>% 
  select(label, region_real, idx) %>% 
  pivot_wider(names_from = idx, values_from = region_real) %>% 
  column_to_rownames("label")

## get node distribution -------------------------------
node_info_annot <-  group_by(node_distribution_raw, node) %>%
  filter(region_prob == max(region_prob)) %>%
  ungroup() %>%
  arrange(region_prob)
rasp_node_info <- read.csv(node_info_file) %>%  
  mutate(time_rasp = round(time, round_digital),
         idx = rank(time)) %>% 
  select(node_rasp = node, time_rasp, idx) %>% 
  arrange(idx)
tree_node_info <- read.beast(tree_file) %>% 
  as.tibble() %>% 
  filter(is.na(label)) %>%
  mutate(time_tree = round(height_median, round_digital),
         idx = rank(time_tree)) %>%
  arrange(idx) %>% 
  select(node_tree = node, time_tree, idx)

node_tab <- left_join(rasp_node_info, 
                      tree_node_info, 
                      by = c("idx")) %>% 
  left_join(node_info_annot, by = c("node_rasp" = "node"))

p <- tree_data <- read.beast(tree_file) %>% 
  ggtree(layout = "fan", ladderize = T) +
  geom_nodelab(aes(label=node))+
  geom_tiplab(aes(label=label)) 

temp_node <- list(ggplot2::ggplot_build(p)$data[[3]],
                  ggplot2::ggplot_build(p)$data[[4]])%>% 
  bind_rows() %>% 
  select(y, x, node_tree = node) 


node_distribution <- select(node_tab, node_tree, region, region_prob) %>% 
  expand_grid(region_sep = region_list ) %>% 
  mutate(value = if_else(str_detect(region, region_sep), 1, 0)) %>% 
  filter(value  > 0) %>% 
  left_join(region_tab, by = c("region_sep" = "region")) %>% 
  select(node_tree, region_real, value, region_prob) %>% 
  mutate(value = value/sum(value), .by = c(node_tree)) %>% 
  left_join(temp_node, by = c("node_tree"))



# plot -------
tree_data <-  read.beast(tree_file)  

as.tibble(tree_data) %>% 
  filter(node == 28) %>% 
  pull(height_0.95_HPD) %>% 
  unlist()*2/365


mrca_age <- tree_data@data$height_median %>% max() %>% 
  round(2)
xlim_seg <- ceiling(mrca_age/5/10)*10



tree_plot <- ggtree(tree_data,
                    layout = "rectangular",
                    # ladderize = T 
                    linewidth = 1)+
  xlim(-40, NA) +
  geom_nodepoint(aes(subset = posterior > 0.8), size = 4) +
  # geom_range(range = "height_0.95_HPD") +
  geom_pie_glyph(data = filter(node_distribution, region_prob > 50),
                 slices = "region_real",
                 values = "value",
                 colour = "grey",
                 linewidth = 0.2,
                 alpha = 1,
                 radius = 0.35)  +
  theme_tree2() +

  geom_tiplab(offset = 10) +
  # geom_nodelab(aes(subset = posterior < 0.9, label = round(posterior, 2)),
  #              # vjust = -0.5,
  #              hjust = -0.5,
  #              color = "black") +
  geom_nodelab(aes(label = node),
               # vjust = -0.5,
               hjust = -0.5,
               color = "black") +
  scale_x_continuous(breaks = seq(mrca_age -5*xlim_seg , 5*xlim_seg, xlim_seg),
                     labels = round(seq(5*xlim_seg, 0, -xlim_seg)) ) +
  theme(axis.text = element_text(size = 14))
tree_plot






p1 <- gheatmap(tree_plot,
               tip_region, 
               offset = -30,
               width = 0.25,
               colnames = F) + 
  scale_fill_manual(values = case1_color_list,
                    na.value = "#FF000000") +
  new_scale_fill() 




```


